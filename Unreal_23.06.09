- 언리얼에서 사용하는 자료형
- signed
형식 int 8

- unsigned  - 형식 uint 8
양수만 사용
각 데이터 타입이 담을 수 있는 범위를 signed는 마이너스에서 플러스 범위까지 반으로 나누어 담는다.
0을 기준으로 왼쪽에 있는 값을 L  value, 오른쪽의 값을을R value라고 한다

- UE_LOG TEXT에서 변수를 담을 때
정수 d
실수 f
문자 s

- 오버플로우
값이 데이터 타입이 담을 수 있는 범위를 넘어가면 반대쪽으로 간다
양의 방향으로 overflow → 음수 쪽으로 넘어감
음의 방향으로 overflow → 양수 쪽으로 넘어감

- float의 정밀도
float이 자신의 데이터 한계를 넘어가면 정밀도에 문제가 생긴다
조건문에서 float을 비교할 때 ‘==’보다 ‘<’,’>’을 사용해야 한다

- 문자열
FString number1 = “1234423432”; 

- 문자열 대응방식
ASCII 코드| 1byte
UniCode | 

- 언리얼에서의 대응방식
TEXT()  → 자동으로 문제에 대해 대응해줌

bool값을 출력할 경우, 정수형으로 출력하면 됨 (%d) → false= 0, True =1으로 출력한다

- 언리얼의 상속
A- : Actor
F- : cpp에서 사용되는 것 + 구조체
U- : 그 외의 언리얼 오브젝트
E- : enum 열거

- 스마트 포인터
언리얼 C++에서 new와 delete가 없을 때 자동으로 메모리를 반납하는 기능
UPROPERTY가 내부적으로 메모리를 관리하는 기능이다

포인터의 개념
메모리 주소를 담는다
주소 +  자료형의 크기까지가 해당주소에 데이터를 담을 수 있는 크기다

- 포인터
자료형 * 변수이름 = 주소

- 포인터와 참조자에 대한 자료 참고
키워드 : temp, swap, 포인터, 참조자, call by value, call by reference

- value, reference를 나눠서 쓸까?
  프로그램 비용(시간, 메모리) 문제 때문이다. 
  value를 쓸 경우 변수가 하나 그대로  복사되기 때문에 메모리 사용이 증가하고 처리 속도가 느려진다.

- 함수의 오버라이딩
	함수를 자식 클래스가 재정의할 수 있게 해주는 기능
  자식클래스는 부모클래스의private 속성에 있는 부분을 제외하고는 모두 상속받음
  부모의 기능을 자동으로 받지만 자식클래스는 해당 기능 이름으로 다른 일을 하도록 오버라이딩을 할 수 있다.
  상속을 받는 기능이 마냥 좋은 것은 아니다. 메모리 관리 측면

- 다형성
자식들은 부모의 성으로써 하나로 분류될 수 있다.

- 함수
 반환 자료형 - 없을때는 void 함수 이름(  인수 )
 {
    return 반환값;
 }

- 접근 제한자
public : 모든 걸 공유 (외부에서 접근할 수 있다)
protected : 가족끼리만
private : 나만

